# Jack parser
# Steven Ruppert
fs = require \fs

symbol = /[\{\}\(\)\[\]\.,;\+\-\*\/&\|<>=~]/
keywords = //^(?:class|constructor|function|method|field|static|var
	|int|char|boolean|void|true|false|null|this|let|do|if|else|while|return)$//

digit = /\d/
string_literal = '"'

identifier_start = /[A-Za-z_]/
identifier = /[\w_]/

comment_start = \//
multiline_comment_start = \/*
comment_end = \*/

escape = -> switch it
	case \< then '&lt;'
	case \> then '&gt;'
	case \" then '&quot;'
	case \& then '&amp;'
	default it
to_xml = ([tag,text]) ->
	"\t<#tag> #{escape text} </#tag>"

lex = (input) ->
	line = 0 # line number
	line_start = 0 # start position in characters of current line
	
	error = -> 
		src = input.split(/\n/)[line].replace /\t/ ' ' # make tabs 1 char wide
		column = i - line_start
		indicator = \- * (column - 1) + \^ # so the indicator will line up
		throw new Error "#it on line #{line+1}, column #{column+1}: \n#src\n#indicator"

	tokens = []
	len = input.length
	i = 0
	while i < len
		c = input[i]
		if c is \\n
			++line
			line_start = i
			++i
		else if /\s/.test c # consume whitespace
			++i
		else if input.substr(i, 2) is comment_start
			++i while i < len and input[i] is not \\n # consume until newline
		else if input.substr(i, 2) is multiline_comment_start 
			do
				++i 
			while i < len and input.substr(i, 2) is not comment_end
			i += 2 # consume comment end
		else if symbol.test c
			tokens.push [\symbol c]
			++i
		else if digit.test c
			integer = c
			while ++i < len 
				c = input[i]
				break if symbol.test c
				error "invalid number" unless digit.test c
				integer += c 
			tokens.push [\integerConstant integer]
		else if c is string_literal
			string = ''
			while ++i 
				error "unterminated string literal" if i > len
				c = input[i]
				break if c is string_literal # end string
				error "invalid newline in string literal" if /[\n\r]/.test c
				string += c
			tokens.push [\stringConstant string]
			++i # discard ending quote
		else if identifier_start.test c
			ident = c
			ident += c while ++i < len and identifier.test c = input[i]
			tokens.push [if keywords.test ident then \keyword else \identifier, ident]
		else
			error "invalid syntax #c"
	
	return tokens

non_terminals = <[ class ClassVarDec subroutineDec parameterList subroutineBody varDec 
	statements whileStatement ifStatement returnStatement letStatement doStatement
	expression term experssionList ]>

terminals = <[ keyword symbol integerConstant stringConstant identifier ]>

class Element
	(@name) -> @contents = []
	push: -> @contents.push it

parser =
	error: ->
		{src, line, column} = @token
		src.=replace /\t/ ' ' # compact tabs to one column
		indicator = \- * (column - 1) + \^ 
		throw new Error "unexpected #{@token.type} on line #{line+1}, column #{column+1}: \n#src\n#indicator"
	parse: ->
		@tokens = it
		# start with only valid top level element
		@el = new Element \class
		@class!
		
		return to_xml @el

	next:~ -> @token = @tokens.shift! or throw new Error "unexpected end of file!"
	peek:~ -> @tokens.0 or { text: \EOF, type: \EOF } # handle missing EOF token
	# manage syntax tree
	start: ->
		@parent = @el
		@el = new Element it

	end: ->
		@el = @parent

	push: (type, text) ->
		t = @next
		text = [text] if text and not Array.isArray text
		# if type is correct and the matching text exists and matches
		if t.type is type and (not text or ( text and text.indexOf( t.text ) is not -1 ) )
			@el.push t
		else
			@error!

	class: ->
		@push \keyword \class
		@push \identifier
		@push \symbol \{
		while @peek.text is \static or @peek.text is \field
			@classVarDec!
		while @peek.text is \constructor or @peek.text is \function or @peek.text is \method
			@subroutineDec!
		@push \symbol \}

	classVarDec: ->
		@start \classVarDec
		@push \keyword <[static field]>
		@type!
		@push \identifier
		while @peek.text is not \;
			@push \symbol \,
			@push \identifier
		@push \symbol \;
		@end!
	
	type: ->
		if @peek.type is \identifier
			@push \identifier
		else
			@push \keyword <[int char boolean]>

	subroutineDec: ->
		@start \subroutineDec
		@push \keyword <[constructor function method]>
		if @peek.text is \void
			@push \keyword \void
		else
			@type!
		@push \identifier
		@push \symbol \(
		@parameterList!
		@push \symbol \)
		@subroutineBody!
		@end!
	
	parameterList: ->
		@start \parameterList
		while @peek.text is not \)
			@type!
			@push \identifier
			unless @peek.text is \)
				@push \symbol \,
		@end!

	subroutineBody: ->
		@start \subroutineBody
		@push \symbol \{
		while @peek.text is \var
			@varDec!
		@statements!
		@push \symbol \}
		@end!
	
	varDec: ->
		@start \varDec
		@type!
		@push \identifier
		while @peek.text is not \;
			@push \symbol \,
			@push \identifier
		@push \symbol \;
		@end!

	statements: ->
		@start \statements
		unless @peek.text is \}
			while @peek.type is \keyword
				switch @peek.text
				case \let then @letStatement!
				case \if then @ifStatement!
				case \while then @whileStatement!
				case \do then @doStatement!
				case \return then @returnStatment!
				default @error!
		@end!

	letStatement: ->
		@start \letStatement
		@push \keyword \let
		@push \identifier
		if @peek.text is \[
			@push \symbol \[
			@expression!
			@push \symbol \]
		@push \symbol \=
		@expression!
		@push \symbol \;
		@end!
	
	ifStatement: ->
		@start \ifStatement
		@push \keyword \if
		@push \symbol \(
		@expression!
		@push \symbol \)
		@push \symbol \{
		@statements!
		@push \symbol \}
		if @peek.text is \else
			@push \keyword \else
			@push \symbol \{
			@statements!
			@push \symbol \}
		@end!

	whileStatement: ->
		@start \whileStatement
		@push \keyword \while
		@push \symbol \(
		@expression!
		@push \symbol \)
		@push \symbol \{
		@statements!
		@push \symbol \}
		@end!

	doStatement: ->
		@start \doStatement
		@push \keyword \do
		@subroutineCall!
		@push \symbol \;
		@end!

	returnStatement: ->
		@start \returnStatement
		@push \keyword \return
		unless @peek.text is \;
			@expression!
		@end!
	
infile =
	process.argv[2]?replace /\\/g \/ or # convert windows paths
	die "Usage: jack.js <infile.jack> or <directory containing .jack files>"
try
	if fs.statSync infile .isDirectory()
		for file of fs.readdirSync infile
			if /\.jack$/.test file
				fs.writeFileSync do
					"#infile/#{file.replace /\.jack$/ \T.test.xml}"
					lex fs.readFileSync "#infile/#file", \utf8
	else
		fs.writeFileSync do
			infile.replace /\.jack/ \.xml
			lex name: infile, input: fs.readFileSync infile, \utf8
catch e
	console.error "Error: #{e.message}"
